9/8
Aim: What is Java? What should be in our Java toolbox?
Language Types: 

Interpreted vs Compiled

Interpreted language code is turned directly into machine instructions via another program
(the interpreter must be used every time)
Examples: Racket, netLogo, Python

Compiled code must be translated into machine (binary) code via another program (the compiler).
The machine code can then be run by a computer. The compiler only needs to be run once.
Examples: Java, C, Pascal, C#, Objective-C, C++
foo.java -----> foo.class
compiled

Functional vs Object Oriented

In a functional language, your main programming task is to write functions which are then executed in order.
Examples: Racket, NetLogo, Python, C

In Object Oriented Programming (OOP), your main programming task is to create classes of objects and have objects interact with each other.
Examples: Java, C++, Objective-C


9/10/14
Aim: What should be in our Java toolbox?
Programming Tools

    Text Editor
        Basic tool for writing code. Programming text editors will have many useful programming features like highlighting, automatic tabbing, auto-completion, etc.
    Compiler
    Interpreter
    IDE (Integrated Development Environment)
        Designed to handle all your programming needs. IDEs will contain a text editor as well as an interpreter/compiler for the language
        Language specific

Java Tools

    javac
        The java compiler

        Basic operations:

        $ javac <source>
        $ javac foo.java
        Will compile/create foo class

    java
        The Java virtual machine (The JVM)
        The JVM allows your compiled Java code to run on any computer that has Java. This is called cross platform. Each platform (computer hardware + OS) has a 		specific JVM.
        The JVM sits between your compiled java files and your computer. It allows any java code binary file to run on the computer.
        Basic operations:

        $ java <java binary source>
        $ java foo.class
        Will run code

9/11/14
Aim: What does a java program look like?

Emacs is designed so that you never have to use the mouse.
When you open Emacs in the terminal, it takes over the terminal. To open it, type:

emacs -nw

If you want to open a specific file, type

emacs <name of file> -nw

In Emacs, there are no scroll bars, and asterisks means that there are unsaved changes.

Some useful shortcuts in Emacs are:
Ctrl-x-c	exit
Ctrl-x-s	save
Ctrl-x-w	save as
Ctrl-x-f	open (find)
Ctrl-g		stop an Emacs action
Ctrl-e		goes to the end of a line
Ctrl-a		goes to the start of a line
Ctrl-s		search
Ctrl-k		cut a line (kill)
Ctrl-y		paste (yank)
Ctrl-z		puts Emacs in the background(does not quit Emacs)
$fg	moves background to foreground

How to print "Good News Everyone!" in java:

public class Hello {
	public static void main(String[] args) {
		System.out.println("Good News Everyone!");
	}
}

Rules of Java Syntax:
    Java is case sensitive
    Class name must match file name, e.g. Hello.java must define a class called Hello
    Regular statements must end in a ;
    Code blocks are contained inside curly brackets {}
    { replaces ; at the end of a line that starts a code block
    } sets the end of a code block
Code Blocks:
    method bodies
    class bodies
    conditional (if, else...) statements
    looping processes
Comments:
// can be used to comment out a single line of code

      e.g. // This will print to the command line

              system.out.println ("boo"); //scary

/*...*/ can be used to comment out multiple lines (block comment)

      e.g. /* This
              Is
              Java */

public class Hello {
	public static void main (String[] args) {
		System.out.println("Hello");
	}
}

Everything within the first set of curly braces is called the method.
"main" : name of the method
"(String[ ] args)" : parameter list
"public static void main (String [ ] args)" : the header
"system...("Hello");" : the body (within the curly braces)

9/16/14
Aim: What’s all this about objects now?

Object Oriented Programming (OOP)	

	An OOP program is a collection of objects
	The properties of an object are defined in a class
		A Class is a blueprint for all objects of the same type
		An object is a specific instance of a class
		An object has 2 parts
			1) Instance Variables : Things the object "knows"
			2) Methods: Things the object "does" [note: this is like a function]
		Instance Variables are declared at the top of a class, before any methods
			You must declare any variables before you use it.
			Variable delcaration includes a name and type.
9/17/14
Aim: What are the parts of a java class? 

public class Greeter {
	//Instance Variable
	private String message;

	//Methods
	public void setMessage( string m ) {
		message = m;
	}
	public void greet() {
		System.out.println(message);
		}
}

While we could compile this file, running it gave an error about a missing method, "main", bringing up runtime vs compiler errors. The compiler can pick up some errors, mainly involving syntax while compiling. However, it is possible for a program to be compilable but still give an error when run.
Also another note, unlike python, java has no required formatting. You can write programs on a single line. Don't do it. Write readable and maintainable code.

Java Class Anatomy:
    Protection/Access restriction: determines access to classes, variables, and  methods
        Public- can be used by any java class
        Private- can only be used by the class itself
        protected- can be used by classes itself and all its subclasses (classes that have the properties of the main class and then more)
    Identifiers: names of variables, classes, and methods
        Can only consist of upper and lower case letters, _ and $
        Can't start with number
Java class template:

<class header> {
	<instance variables>
	<methods>
	}

Class Header:

<protection> class <identifier (class name)>

//By convention class names start with a capital letter and use camel case 
//e.g. public class Example, public class CamelCaseIsLikeThis


It is common practice to make the instance variables private but methods public so that any class can change the instance variable as long as it follows the rules set by the class.

Instance Variables:
     <protection> <type> <name>
     name
          By convention, variable names start with a lower case letter and use camel case
     type
          All variables must have an associated type. 
          The type can either be a primitive datatype or an java class.
          Assigning a variable a type tells the compiler to map the variable to a certain chunk of memory. 
method header
     <protection> <return type> <name>(<parameters>)
     name
          Like variable names, method names usually start with a lower case letter and use camel case. 
     parameters
          Parameters must be given a type and a name like any other variable.
          Multiple parameters are separated by commas. 
          Even if the method in question does not have parameters, you still need the parentheses. 
     return types
          If a method returns a value, you must declare what kind of value is returned.
          If a method does not return a value, then the return type should be void. 
     Two or more methods in the same class can have the same name so long as they have different parameters. This is known as overloading. 
     The parameters must be changed to overload the method. Only changing the return type or the protection will not work. 
main method
     Each class can (but doesn’t have to) contain a method called main.    
     Main is special, it is the only method that is run automatically.
          $ java Hello
          will run the main method inside the class Hello. 
     The main method must have the following header:
          public static void main(String[] args)
          For the time being, ignore the word static. 
          “static” is a modifier.  

9/19/14
Aim: How do we get an object?

public static void main(String [] args){
	int x;
	x = 4;
	System.out.println(x+17)
}

This returns 21

 

Creating Objects

    In order to create an object(an instance of a class), you must call a special method known as a constructor
    By default, all java classes have at least 1 constructor
    the name of a constructor is always the name of the class itself
    in order to use a constructor you use the Keyword: new

Greeter g;
g = new Greeter();
g.setMessage("Good news everyone");
g.greet()

This will return the message "Good news everyone" when Greeter is run. 

9/22/14
Aim: What are the Java Primitive Data Types?
    double, float - 1.01 (Not to be confused with Decimals)
    boolean - True/False
    int - 21, -18
    String - "abc"
    char - 'a'

Using Variables
Creating and using a variable takes two steps, declaration and initialization.
Declaring a variable states what kind of type it is.

ex. int x;
     String s;
     Greeter g;

Initialization gives a variable an initial value.

ex. x = -24;
     s = "Hello";
     g = new Greeter();

Declaration and Initialization can be done on a single line

ex. int x = -24
     String s = "Hello";
     Greeter g = new Greeter();

Primitive data types: The only data types that are not classes
Six different data types for numbers exist in Java

Data type table
Type			Name		Data size (bits)	Range

Integers		byte		8	  		[-128, 127]
			short		16		        [-215, 215 - 1]
			int		32			[-231, 231 - 1]
			long		64			[-263, 263 - 1]
Floating pts		float		32			seven digits of precision
	 		double		64	      	     	fourteen digits of precision
Characters		char		16		 	one character
Boolean values		boolean		?			true or false

9/23/14
Aim: How do we write our own constructors?
//Default Values
    If a variable is not initialized it is given a default value.
   -All numeric primitives are set to 0.
   -boolean primitives are set to false
   -Characters are set to '' (empty/null character)
   -Strings are set to "" (empty/null string)
   -All object variables are set to null (nothing)
//Constructor
   Java creates a default constructor for every class.
        The default constructor takes no parameters and will set all instance variables to their default values.
   You can write your own constructors using this header.

<protection> <class name> (<parameters>)

***Note that the name of the method is the name of the class. Also, there is no return type as it will be the same as whatever you're constructing.
Constructors can be private or protected, but are most often public.
Example of constructors:
Default constructor:

public Greeter() {
	message = "Hello";
}

Constructor with parameter:

public Greeter( String m ) {
	message = m;
}


9/24/14 Making Our Own Code

We were given the instruction to go to the class website and look at the work for today. These were the instructions to be followed in class:
We will begin by creating a java class to represent a simple bank account with the following features: 
    Instance Variables
        Account holder's full name
        Account password
        ATM pin number (some 4 digit number)
        Account number (some 9 digit number)
        Account balance (money in the account)
    Methods
        A constructor that takes parameters for each instance variable and sets them accordingly
        Methods to set each of the 5 instance variables individually
        A method to print out all of the account information at once
        A deposit method that will take an amount of money as a parameter and add it to the account balance
        A withdraw method that will take an amount of money as a parameter and remove it from the balance
        A main method that tests your code
A few pointers:
    Select the appropriate data type for each of the instance variables. (If a floating point is not needed, use an integer type.)
    TEST YOUR WORK. Write a single method at a time and then test it.
Submit this as bankaccount(included in this repo!)


9/29/14
Aim: How do conditional statements work in Java?

Arithmetic Operators

+, -, *, /, % 

% ==> Modulus operator, takes the remainder of a division problem for positive numbers
Division is dependent on the type used
integers / integers = integers
      - Ex. short / int = integers
Integer division will truncate, meaning it will cut off the result at the floating point.
All other combinations of number divisions (floats, doubles, etc.) ==> float
It will always go for a more precise value when dividing, so int => float, not float => int.
Ex. Literal number assumed as int => 2
      Literal number assumed as double => 2.0

Shorthand Operators

+=, -=, *=, /=, %=

Java will do the operation indicated, and bind the new value to the variable.
Ex. x += 1; //Adds one to the current value of x and binds it to x
    x -= 10; //Subtracts ten from the current value of x and binds it to x

Increment Operators

++, --

Will increment by 1.
Ex. x++; <==> x += 1;
    x--; <==> x -= 1;
x++ ==> returns x then adds one to it
++x ==> adds 1 to x then returns x
This difference is prominent when trying to be clever when printing numbers.

Comparison Operators

>, <, >=, <=, ==, !=

Returns a boolean
== is the sign meaning "equal", as = is the sign meaning binding
Ex. x = 5;   //Binding the value 5 to the variable x (Assuming it is declared already!)
    (x == 5); //Checks to see if the value bound to x is equal to the value 5 and returns true or false

Boolean Operators

&& ==> and
|| ==> or
! => not

| is not an "i', but is the key obtained when pressing SHIFT with the backslash key (above enter)

Conditional Statements
	    if (<BOOLEAN>) {
      	       <RESULT> 
	    } 
 	    else if (<BOOLEAN>) {
	       <RESULT>
	    }
	    ... // (However many repeats you want, could be zero!)
	    else {
     	       <FINAL RESULT>
	    }
// else is, of course, optional! 

9/30/14
Aim: How do conditional statements work in java?

	String a = new String("hello");
	String b = new String("hello");
	System.out.println( a == b );
//This prints false

Object Comparison
    You cannot use >, <, >=, <= on object variables
    == and != will check to see if two object variables refer to the same piece of memory, not if they have the same "value"
Many classes (including string), have an equals method that can check for value equality

Ex.	String s = new String("hello");
	s.equals("hello");
//This returns true

10/3/14
Aim: How do the basic Java loops work?
Loops in Java
while loop

    Will run as long as a condition is true

Syntax:
	while(<BOOLEAN>){
		<CODE>
		}
Example:
	int fact = 1;
	int n = 1;
	while (n <= 5){
	      fact = fact * n;
	      n++;
	      }
for loop
    "Counting loop". Will run as long as a condition is true
    Has built in initialization and update code for a counter
Syntax:
	for(<INIT>; <BOOLEAN>; <UPDATE>){
		    <CODE>
		    }
Example:
	int fact = 1;
	for (int i =1; i <=5; i++){ //Initialization only happens once
	    fact *= i;
	    }
10/7/14
Aim:  Refining our classes
When it comes to making testing methods in the main methods, there are ways to do this that make the tests more informative.
    Use print statements to explain what is being displayed
    Place comments in code to explain what each part of the code is doing or should return
Testing display():
22 / 34
0 / 1

Testing add():
1 / 2
plus
3 / 4
equals
10 / 8

Testing reduce():
10 / 8
equals
5 / 4
Some pointers for the RationalNumber class:
    Remember that a class is a blueprint for an object and not specific.
Notes about RationalNumber class:
    Passing an object of the same type as a parameter will allow you to access the instance variables and methods of the parameter directly:

        public void multiply (RationalNumber other) {
        	numerator = numerator * other.numerator;
        	denominator = denominator * other.denominator;
        }

    The keyword this can be used to represent the object calling the function:

        public void multiply (RationalNumber other) {
        	this.numerator = this.numerator * other.numerator;
        	this.denominator = this.denominator * other.denominator;
        }

    When testing add...

        System.out.println(r + " + " + s);
        //r and s are RationalNumber objects

        Note that this probably will not give you what you were expecting/wanted

        RationalNumber@6bf88953 + RationalNumber@9ffdf86
        //Prints out the memory addresses in hexadecimal

        To fix this, the toString() function must be modified.  See 10/8/14 minutia

10/08/14
Aim: What's up with that static thing anyway?

toString
    Returns a String representation of an object. Java will automatically call toString whenever you use an object variable in a String context.
    Every object has a toString method (just like a default constructor and equals). The default toString method will return the class name and the memory location of the object.
    Different pieces of memory are used almost every time program is run (not when run at small time intervals)
    Example:

    RationalNumber r = new RationalNumber();
    System.out.println(r);
    System.out.println(r.toString());

        If toString is default, both print out the same value - RationalNumber@<memory location in hexadecimal>
        If toString is not default, both print out the same value (whatever is defined in the method)
    Header: public String toString()
        Could be used as a display function, where you define what it should print
    Is class-specific
        If bankAccount is printed from RationalNumber, and toString is default in bankAccount, it will print default toString value for bankAccount
Calling classes from other classes
    If two classes are in the same folder, one can be called from the other by writing <CLASS> <VARIABLE> = new <CLASS>;
    Example (from RationalNumber):

    bankAccount b = new bankAccount(...);

static methods
    A static method is a class method not attached to any particular object
        Main class
        Math class
    Cannot access instance variables
    Are run by a class and not by an object
    To call a static method, use <CLASS>.<METHOD>(...);
        Generally safer than just <METHOD>(...);
10/9/14
Aim: Fire Drill and GCD
In our RationalNumber2 homework assignment, we were given the following link to assist in creating a GCD method:
http://www.cut-the-knot.org/blue/Euclid.shtml
Though the method seems recursive, the purpose of doing this method for HW was to use a loop, like we learned in class on 10/3. 
The GCD While Loop:
The Header/Condition:
The following condition tells Java to keep performing the code in the curly braces so long as the remainder of (a / b), "a divided by b", is not equal to 0, or so long as the condition is true.

while ( (a % b) != 0 ) {...}

ERROR: Why won't this work?
Assuming a > b:

while ( (a % b) != 0 ) {
	a = b;
	b = ( b % a );
}
//This will not work because of the ordering of the lines matter.

This code first sets the value of a to the value of b, then sets b to the remainder of (b / a). But a was first modified to become the value of b, so since (a = b), the line (b = b % a) is actually like saying (b = b % b). Here's an example of what this code would produce:
---Before run code---

a = 2322

b = 654

---After run code---

a = 654

b = 654 % 654  //so b now equals 0, making the while loop condition false and thus, stopping the while loop

Working GCD method
The error discussed in the previous section can be fixed by declaring a new variable holding the value of a. 
After a becomes the value of b, in the next line, we can use tmp, which holds the original value a, to divide (b % tmp).

while ( ( a % b ) != 0) {
	int tmp = a;
	a = b;
	b = (b % tmp);
}

10/10/14 
Aim: How to write a Role-Playing Game (RPG)
We are creating a text-based RPG. One famous example of such a game is Zork.
Let's try creating our classes of objects:
First a warrior class:

public class Warrior {
	int health;
	int damage;
	String name;
	int xp;

	public Warrior(){
		health =20;
		damage=8;
		name = "Bob";
		xp=0;
	}

	public void attack(){
		System.out.println("AGHHHHHHH")
	}
}

Now lets create a mage

public class Mage {
	int health;
	int damage;
	int name;
	int xp;	
}

....and 1000 more types of things...

That is too tedious!
What do the characters have in common?
Health, damage, etc.

Let's try to create a superclass called character.

public class Character {

	// Instance Variables
	int health;
	int xp;
	String name;
	int damage;

	// Methods
	public Character() {
		xp = 0;
		name = "Bob";
	}

	public void attack() {
		System.out.println("I'm attacking");
	}
}

 We can do this because Java is polymorphic
Polymorphism
    Allows multiple classes to share instance variables and methods
    Java can have superclasses and subclasses; subclasses can inherit instance variables and methods from superclasses
    Some characters have common attributes so a superclass can be created so that subclasses can inherit instance variables and methods
        example of a superclass and subclass hierarchy:

                                                     Character
                                           ______________|______________
                                          |              |              |
                                       Warrior          Mage           Tank
                                                         |
                                                       Healer

We can create a subclass of our new character class by using 'extends':
Example:

public class Mage extends Character {
	public Mage() {
		health = 10;
		damage = 1000;  // Because Mage's are overpowered
	}

	public void attack() {
		System.out.println("pew pew");
	}
}

Because we are referencing 'character' in our new mage class, we want to make sure the two class files are in the same folder (for convenience).
In addition, we would want a separate game driver class. Here's how it would look if we have a Character class along with a Warrior class that extends it:

public class Game {
	public static void main(String[] args){
		Character c = new Character;
		Warrior w = new Warrior();
		w.attack();
	}
}

10/14/14
Aim: How do we extend classes?
Do Now: Create a Character class with the following:
Instance Variables:
    name
    health
    damage
    experience
Methods:
    Default Constructor
    Constructor that takes name as a parameter
    Attack (right now just print something)

public class Character {
	// Instance Variables
	int health;
	int xp;
	String name;
	int damage;

	// Methods
	public Character() {
		xp = 0;
		name = "Bob";
	}
	public Character(String n) {
		name = n;
	}
	public void attack() {
		System.out.println("I'm attacking");
        }
}

extends - Java keyword used to create a subclass
ex: public class Mage extends Character{
You cannot extend your class to multiple classes, but you can have subclasses of subclasses
    public class Healer extends Mage{
Obtains all of the info from Mage, which also has all of the info from Character
Subclasses inherit all instance variables and methods except for constructors
The private keyword will restrict the information in the variable to only that class
    private int health;
If a subclass of the class where health is declared tries to call health, it will get an error
Private instance variables are inherited by subclasses but cannot be accessed by the subclass
one should use protected instead when making an instance variable which will make it accessible to the class and all of its subclasses only
    protected int health;
This will allow any subclasses that extend to the class with variable health to access it
Method Inheritance - subclasses can create their own version of inherited methods
    this is called overriding
        note that this is different from overloading a method because they are not in the same class

public String toString() {
        String s = name + " ";
        s += health + " ";
        s += damage + " ";
        s += xp;
        return s;
    }

Here is the toString() method for character in order to tailor it for the Mage class, one can either override the toString() method of Character and make a totally separate one for Mage

public String toString() {
        String s = name + " ";
        s += health + " ";
        s += damage + " ";
        s += xp;
	s += energy
        return s;
    }
Or one can call the superclass version of a method by using the super keyword
   String s = super.toString() + energy;  

10/15/14
Aim: How do we get text input?
To create a text-based RPG, we will need user text-based input.
We will use the scanner class.
It can get input from user, other files, devices,etc.
System.in:terminal input
Text input during your program:
    Scanner
        Java class to get input from the terminal or files
	        Scanner can = new Scanner( System.in );
        	can.nextLine();
            This will make your program wait until the user has typed something and hit return
            Returns what the user entered, as a string.
	            can.nextInt(), nextDouble() ...
            works like next but returns an int, double...
            If the user enters the wrong type, an error occurs

import java.util.*;//this imports all utility classes that are not directly included with Java, such as Scanner
public class Input{
    public static void main(String[] args){
        Scanner s = new Scanner( System.in );
        int x;
        String t;

        System.out.print("Enter a string: ");
        t = s.nextLine();
        System.out.print("Enter an int: ");
        x = s.nextInt();
        System.out.println(t);
        System.out.println(x);
    }
}

This code prompts for a string first, then an int. Then it prints the string and int the user entered. If the user entered a different type, such as a doble when it called for int, then this error would occur: InputMismatchException.


10/16/14
Aim: How can classes in the same hierarchy interact?
You can use the super constructor by just using super. Super on its own refers to the super classes’ constructor.

public Character() {
	health = 10;
	damage = 8;
	xp = 0;
}
public Mage() {
	super(“Molly”);
	damage += 10;
	energy = 5;
}
public Warrior() {
	super(“Wally”);
	health += 10;
	damage = 8;
}

Method Inheritance
To call a superclass constructor, use super by itself
ex: super();
    super("dude");
if the super class does not have a constructor it will not work
Constructors are not inherited, but java automatically assumes the first line of a constructor is a call to the superclasses default constructor, unless you explicitly call a different superclass constructor.
Call to super must be the first statement in the constructor or you will get an error.

public Mage() {
	damage += 10;
	energy = 5;
}

Java has a class called Object. At the top of every class hierarchy is Object, which is why every class gets a default constructor.
Object class
All classes are subclasses of Object unless they explicitly extend a different class
The Object class contains a few basic methods such as:

    .toString
    .equals
    default constructor

Variable type vs. Object type
Variable type
the type declared in your code.

String s ⇒ Variable type is String
Object o ⇒ Variable type is Object
Mage m ⇒ Variable type is Mage

Variables can only use methods that are defined in their variable type class.

o.toString();
o.attack(); will not work 

Object type
The type created in memory.
Tied to which constructor was used to create the object.

String s = new String() ⇒ Object type is String
Object o = new Object() ⇒ Object type is Object
Mage m = new Mage() ⇒ Object type is Mage

Variables can refer to any object that is below the variable type in a class hierarchy.

Object o ⇒ o can contain any kind of object
Object o = new String();          o is an Object variable that refers to a String object
Character c = new Mage();     c is a Character variable that refers to a Mage object

10/17/14 
Aim: Object Type vs Variable Type Revisited
A variable can refer to any object below its type in a class hierarchy.
    Character variable can refer to a Mage or a Warrior
    Mage variable can only be a Mage.
    Consider Object o = new Mage();
        Left side is variable type (object, in this case)
        Right side is object type, determined by the constructor used (Mage, in this case).
A variable can only use the methods declared in its variable type.
    o.toString();
        Valid because the method is in the object class and accessible.
    o.attack();
        Does not work because o cannot access the attack method.
        Do not get confused and think that o doesn’t have an attack method
            o is an object that has the method thanks to the constructor; it just can’t get to it.
            o has all the Mage methods but cannot use them because its variable type is too generic (meaning: o is too high in the class hierarchy).
        The variable type determines what methods it CAN use, not what methods EXIST.
When a method is called, the object type's version is used.
    Meaning: the object type determines HOW the method will be used.
    o has toString(), but uses the Mage class’s version of toString()

10/20/14 
Aim: Stuyablo Assignment
Minimum Requirements -
    2 different playable character types
    2 different enemy character types (ie. generic enemy & boss)
    1 Game driver class 
        allow interactions: enter name, select character types, begin game interaction, pick up item, etc.

10/23/14
Aim: How can we get random numbers in Java?
Random class - Designed for generating random numbers
Imported through java.util.*
import java.util.*;
Methods:
.nextDouble() - Returns a random floating point number in the range 0 <= n < 1
.nextInt() - Returns a random integer in the range -2^31 <= n < 2^31
.nextInt(int bound) - Returns a random integer in the range 0 <= n < bound
Mathematical operations can be used along with the random number generating to change the possible values.
Testing Random Class Usage:
	Random r = new Random()
	for(int i=0; i < 10; i++) {
		System.out.println(r.nextInt());
		System.out.println(r.nextInt(10));
		System.out.println(r.nextDouble());
		}
10/24/14
Aim: What is the Aim?
What does super do?
super.methodname() calls methodname() in this class's superclass. That is, given the three classes below (which should be in separate files):

public class Below extends Above {
	public void teletubbies() {
		super.teletubbies();
		System.out.println("Below");
	}
	public void quinoa() {
		super.quinoa();
	}
	public Below() {
		int x = 1389;
	}
	public static void main(String[] args) {
		Below a = new Below();
		a.teletubbies();
	}
}

public class Above extends Master {
	public void teletubbies() {
		System.out.println("Above");
	}
	public void quinoa() {
		super.quinoa();
	}
	public Above() {
		int y = 86400;
	}
	public static void main(String[] args) {}
}

public class Master {
	protected int x,y,z;
	public void teletubbies() {
		System.out.println("5");
	}
	public void quinoa() {
		System.out.println("Quinoa");
	}
	public Master() {
		int z = -273;
	}
	public static void main(String[] args) {}
}

super.teletubbies() in class Below calls telletubies() in Above.java, such that running Below.java should print out "Above", then "Below".
In your methods, you don't have to use super; it is possible to have your identically named methods to do totally different things. For example, teletubbies() in class Below could instead print a number.
Note that super can only be used to call a superclass one level up (the class that is being extended). In the above example, super.teletubbies() in class Below calls teletubbies() in class Above, and not in class Master, which is two levels up.
If you want to call a method in a superclass two levels up, you can use a super chain, demonstrated in the quinoa() methods in the above example. quinoa() in class Below does the same thing as quinoa() in class Above and Master.
Constructors are special; they are not inherited, unlike other methods.
Instead, Java automatically calls the superclass's default constructor, which is equivalent to super(). This means putting super() in the first line of the constructor is redundant, unless you want to specify parameters (ex. super(int length); ). As constructors are not inherited, you cannot override (this is distinct from overloading) a constructor. Also, constructors must at least do what the superclass's constructor does (see second sentence of this paragraph). For example, the constructor in class Below will z, y, x, in that order.

10/28/14
Aim:How do we work with arrays?
Array
     Simplest Java data structure. A data structure hold multiple pieces of data(ex. dictionaries, lists etc.)
      An array is a contiguous block of memory used to store multiple values of the same type. 
Arrays have a fixed size
      An array can be reinitialized to a new , but will erase all the data stored in it.
      Each element will contain the default value for the array's data type until modified.
Basic Array syntax

int[] ray; //Array declaration
ray = new int[10]; //Array initialization
ray.length; //returns length of the array
System.out.println(ray); //prints out memory location

[ ]s are used to access values in the array.

ray[0]=75;
ray[i]=75; //works but 0<=i<ray.length

Initilizer Lists
Used to create arrays with preset values

char[] cray = {'a','b','c'};
//This will create a 3 character array with the values 'a', 'b'' and 'c'
 
10/30/14
Aim: How can we work with Arrays?

// Assuming Stat class is already defined;
public int findMin(){
	int guess = data[0];
	for (int i = 0; i < data.length ; i++)
		if (guess > data[i])
			guess = data[i];
	return guess;
}			

"Hold on, friend. Aren't you missing some necessary curly braces for that 'if'?"
Actually, no. For Control-Flow Statements (Conditional, Loops, etc.), no brackets are necessary if there is only a single line of code in its code block as Java assumes they are there. However, you may include brackets if you wish.
"Then why can 'for' contain the two line if-then statement and not need brackets?"
This is due to the ability to nest the control-flow statements where the resulting code-block of a nested control-flow statement will not be considered part of the original control-flow statement by Java.
This should not, however, make you get used to not using brackets. This may eventually become detrimental if you need to add more code to your code-block, such in adding print-statements in order to bug-fix. Use of this short-cut/brackets is under your discretion, as long as it does not interfere with the effectiveness of your code.

11/03/14
Aim: How can we make arrays better?
Some limitations of arrays:
    Arrays are of a fixed size. 
    Arrays can only hold one type of data.
    Arrays cannot have negative indices.
    Values in arrays cannot be appended. 
    Arrays cannot give the index of a given value. 
How might we go about fixing these problems?
SuperArray 
    Create an instance variable that is an array of Objects : 
        Object[ ] data
            This already takes care of the problem in which an array can only hold one type of data.
            How do we append a value? Create a new array.
            The new array would consist of the “used” and the “unused” space.
            The size would refer to the space where the “used” space ends.
                For this, create a variable int size.
    Conclusion
        Instance Variables :
            Object[ ] data
            int size                                                                                                                                              
        Methods :
            default constructor
            size based constructor
            copy
            insert (add anywhere)
            append (add at the end)
            concatenate
            resize
11/4/14
Aim: How can we write our improved array class?
Instance Variables:
    Object[] Data;
    int size;
Methods:
    resize: make a new array and copy old values over
    add: append an element to the end of the end of the used space
    remove:
    add(int i): add to position i
    slice(int s, int e): returns the portion of the array from s to e
    toString
    size(): return the number of used positions
    get(int i): return the element at position i
    replace(int i ,Object o): put o at position i
    find(Object o): find object o in the array

11/6/14 superArray Review (period 10)

11/6/14 
Aim: superArray Review
// Constructors
public SuperArray() {
	data = new Object[10];
	size = 0;
}
public SuperArray(int s) {
	data = new Object[s];
	size = 0;
}

public String toString() {
	String s = "";
	for (int i = 0; i < size; i++) 	// Use size as the compared value instead of the length of the array!
		s += data[i] + " ";
	return s;
}

private void resize { 	// PRIVATE because other don't need resize as long as you apply it correctly!
	Object[] newData = new Object[s];
	for (int i = 0; i < data.length; i++) 
		newData[i] = data[i];
	data = newData;		// ***
}

public void add(Object o) {
	data[size] = 0;
	size++;
	if (size == data.length)
		resize(data.length + 10);
}

public static void main(String[] args) {
	SuperArray sa = new SuperArray();
	for (int i = o; i < 15; i++) 
		sa.add(i);
	System.out.println(sa);
}


11/7/14
Aim: How does type casting work?
Integers can become a double without a problem.
Rule of thumb:
You can go from something that is less precise to something that is more precise (for primitives). Java will allow you to do this automatically.
You CANNOT do this backwards. A double cannot be forced into an integer normally. In fact, Java will not even allow you to compile if it believes you are losing precision.
Type Casting
       Using a value as a type other than its declared type.

byte b = 65;
(double) b
//Returns 65.0

double d = 1947.24
(int) d 
//Returns 1947

All primitives (except for booleans) can be type cast to one of the other primitive types. This will ignore problems about precision.
Type casting does NOT change a variable. Type cast can change the type it is, but it cannot modify a variable.
syntax:
    (<NEW TYPE>) <VALUE/VARIABLE>
    (double)4
    (int) 13.8
    (short)x

char c = '%';
byte b = 65;

System.out.println( (int) c);
//Will yield 37

System.out.println( (char) b);
//Will yield 'A'

Type casting has precedence over all the arithmetic operations, but NOT over dot.

An object variable can be typecast to its object type or any type above it in a class hierarchy.

Object o = new String("String");
String t = o;
//Returns an error: incompatible types. o is an object, but String t requires a String.

Object o = new String("String");
String t = (String)o;
//Works fine.

int i = (int)o;
//Compiles fine, but runtime error: ClassCastException, incorrect type casting.

System.out.println(t.toUpperCase());
//Makes all the letters UPPERCASE. Returns "STRING".

System.out.println( (String) o.toUpperCase() );
//Returns an error, because the type casting works only after the method is called.

11/13/14
Aim: ArrayList Methods
There are six methods in ArrayList that are on the AP exam.  You can use other methods on the exam as long as they don't solve the problem for you.
int size()
	Returns the amount of elements in the array.

boolean add (Object o)
	Adds o to the ends of the ArrayList
	Returns true (never returns false because ass is always successful)

void add (int i, Object o)
	Adds o to position i in the ArrayList
	All elements at position i or later are shifted to the right
	0<= i <= size() (remember: Java doesn't allow negative indices)

Object get (int i)
	Returns the element at position i
	0<= i < size()

Object set (int i, Object o)
	Replaces the element that was at posiition i with o
	0<= i < size()

Object remove (int i)
	"Removes" the element at position i
	All elements after position i are shifted to the left
	Returns the element that was removed
	0<= i < size()
	
11/19/14
Aim: XLint
For example, you'd need to use typecasting to get ((numberTile) board.get(i)).getRight();
because an object doesn't have getRight(). We looked at examples of this and talked about the "cannot find symbol" error and why it comes up after compiling rather than before.
Typecasting goes against Java's approach to typing. In other words, it says "this object is actually a string" and forces Java to treat it as such.

 

We also talked about the "warnings" that ArrayList gives us rather than errors. 

Saying "javac foo.java -Xlint" gives more details on the type-based warnings.


Lastly, we learned how to specify if a list is comprised entirely of one type of thing. When you initialize and substantiate an ArrayList, you can write the 'type' in angle brackets (ie gang signs).

For example, you can say "ArrayList<int>" to specify an ArrayList of integers. Firstly, this returns actual errors rather of warnings. Secondly, there's no need for typecasting. This function, for example, would return all ints when .get is used.

 

We can do this because of generics. Generics are almost like arguments, except that you specify a type, which the method or class can then use.  For example, take "SuperArray<E>". E will be later replaced by a type like "int" when you call the class and insert a type into the brackets. 

You can then write lines like "private E[] data..."  or "data = (E[])new Object[10];", and E will be replaced by that type.

11/24/14
AIM: How can we use multi-dimension arrays?
Multi-Dimensional Arrays
An array can contain any type, including other arrays.
An array of arrays is called a two-dimensional array.
syntax:
int[][] a2d = new int[4][5];
// the first number is the amount of arrays
// the second number is the size of each array
 _        _ _ _ _ _

|_| ---> |_|_|_|_|_|
 _        _ _ _ _ _

|_| ---> |_|_|_|_|_|
 _        _ _ _ _ _

|_| ---> |_|_|_|_|_|
 _        _ _ _ _ _

|_| ---> |_|_|_|_|_|

Finding the lengths
    a2d.length returns 3
    a2d[0].length returns 4
2-D arrays are normally rectangular
You can use initializer lists with 2-D arrays, this is the only way to have a jagged (non-rectangular) 2-D array.
syntax:
int[][] jag = {{1,3,4}, {9,2}, {8,6,0,7}}
*You can use nested for loops to populate 2-D array or display 2-D array

public class A2dFun {

	public static void main(String[] args) {
		
		int[][] a2d = new int[4][3];

		// Adding values to a2d
		for (int i = 0; i < a2d.length; i++)
			for (int j = 0; j < a2d[i].length; j++)
				a2d[i][j] = j + i * a2d[i].length;

		// Printing out a2d
		String s = "";
		for (int i = 0; i < a2d.length; i++) {
			for (int j = 0; j < a2d[i].length; j++)
				s += a2d[i][j] + " ";
			s += "\n";
		}

		System.out.println(s);

	}
}

12/2/14
Aim: How can we keep ArrayLists in order?
add(value) - needs to put the value at the correct spot
set(index, value)- has to be resorted. remove and then add back the number? 
add(index, value)- does not work with OrderedArrayLists

Methods that we can keep
get(index) - does not affect order 
size() - does not affect order
remove() - does not affect order

12/3/14- OrderedArrayList - Add method
Aim: How can we use the same methods across different classes?
Do Now: Write the add method for OrderedArrayList.
Common problems encountered in the do now:
When you add, the data size increases, so you will enter an infinite loop.
Did not account for size = 0.
If the added term is greater than all the other terms, then it should be added at the end.
When you have a void return method, you can still use "return" to signify the end of a method.
Boolean short circuiting- if the first part of a conjunction is false, then java doesn’t evaluate the rest of the condition. In an or statement, if the first part is true, then the second part is not evaluated.

import java.util.*;

public class OrderedArrayList {
    
	private ArrayList<Integer> data;

	public String toString(){
  	  return data.toString();
	}
    
	public OrderedArrayList(){
 	   data = new ArrayList<Integer>();
	}
    
	public void add(int value){
 	   int i = 0;
  	  while(i < data.size() && value > data.get(i))
  	  	i++;
  	  data.add(i,value);
	}
    
	public int remove(int i){
 	   return data.remove(i);
	}

	public int get(int i){
 	   return data.get(i);
	}

	public int size(){
 	   return data.size();
	}
    
	public static void main(String[] args) {
 	   OrderedArrayList oal = new OrderedArrayList();
    
	    oal.add( 3 );
	    oal.add( -2 );
	    oal.add( 1 );
	    oal.add( 9 );
    
	    System.out.println( oal );
	}
}

12/5/14
Aim: What are Interfaces?
How could we sort various objects?
With an interface
Interface - A Java interface allows multiple classes to share the same method behavior.
Interfaces can only contain abstract methods and constants.
Interfaces cannot have constructors, regular methods, instance variables.
Abstract Methods
-Method headers without bodies. 
-Used so that you can have the same name/return type but different algorithms.
Syntax

<Protection> abstract <type> <name>();
public abstract Char foo(int x); 

Comparable 
-Java interface that contains a single method

public abstract int compareTo( Object o);
a.compareTo(b) returns
	0 if a == b
	negative if a < b
	positive if b < a

Comparable - interfaces allow you to objectively compare two object of the same type

12/8/14
Aim: How can we search smarter?

Comparable review:
-a.compareTo(b) returns 0 if a = b;
-a.compareTo(b) returns a negative number if a < b;
-a.compareTo(b) returns a positive number if a > b;

This is the search function:

public int search (Comparable value) {
 	for (int i = 0; i< data.size(); i++) {
		if value.compareTo(data.get(i)) == 0) {
 			return i;
 		}	
 	}
 	return -1;
}

This algorithm is called the linear search algorithm.
Say we had the array {a, c, d, g, k, m, o, q}.
With linear search , it would take at most 8 passes to see that an element we are searching for is not in the array.

A more efficient algorithm is the binary search algorithm:
1) split list in half
2) see if what your searching for is before/ after the halfway mark
3) repeat
 
Finding the value "m" in the above array would only take 2 passes; The worst case scenario, in which we search for a value that is not in the array, would still only take 3 passes (assuming the size of the array was 8).

12/9/14:
Aim: How does the binary search work?
Do Now: Write a new version of the new search function, but this time. use the binary
search algorithm.

Today we continued our discussion on the binary search method, a faster and more efficient method of finding the index where an element is located instead of going through each element from the first. In case anyone forgot, binary search makes use of the fact that the list is ordered and starts by checking the middle value in the list. If it happens to be the element we want, then of course we get it in a single try. If it's not though, depending on whether the object we're looking for comes after or before the middle element, we'll look at section of the list before or after the middle element. We then run the same procedure on this section, essentially halving the number of elements we have to consider with each step, until we find the element we are looking for, or determine that is not in the list. 

We then took some time to write our own implementation of binary search. First we examined the algorithm a bit more closely on an example list:

Target: o
a, c, f, m, o, q, w, z
0, 1, 2, 3, 4, 5, 6, 7

We looked at the start, end and middle of the search space after every step.
For the first run through, index 0 is the first position, and index 7 is the final. We chose the middle to be 3 since 7/2 conveniently returns 3. Since m =/= o, we went on to a second run.
This time 4 was the lower index and 7 still the higher. The middle we picked to be (7+4)2 -> 5, being consistent with our choice of using the left middle value. Since q =/= o, we ran the algorithm once again.
Since q is "greater" than o, we considered the left half. The starting index was still 4, and the ending index 5. The middle value (4+5)/2 -> 4, which is o. Since this is what we are looking for, this ends the algorithm.
While there are many solutions to creating a binary search method, the nature of the method lends itself to a particularly simple and elegant recursive solution.

This is  the recursive solution that was shown in class, involving a helper method.

public int rbsearch( Comparable c ){
	return rbsearchHelper(c, 0, data.size() - 1);
}

    
public int rbsearchHelper(Comparable c, int lo, int hi){
	if (lo > hi){
	    return -1;
	}
	
	int mid = (lo + hi) / 2;
	int comp = data.get(mid).compareTo(c);

	if(comp == 0){
	    return mid;
	}
	
	else if (comp < 0){
	    return rbsearchHelper(c, mid + 1, hi);
	}
	
	else{
	    return rbsearchHelper(c, lo, mid - 1);
	}
    }

12/10/14
Aim: How can we analyze algorithm  efficiency?

we went over type casting:
must go from high precision to low precision. otherwise unnecessary.

we went over primitives in type casting :
not all primitives can be type casted to any other primitive because booleans cannot be type cast to anything else.

also many people incorrectly coded question 10b because when removing values from an ArrayList in a for loop using i for indexing. when the element is removed i-- must also be used to ensure that no elements are skipped over

Mr. DW then showed us the non-recursive way to do binary search which is:

public int bsearch(Comparable c) {
	int lo = 0;
	int hi = data.size() - 1;
	int mid = 0;
	while(low <= hi) {
		mid = (lo + hi)/2;
		int compVal = data.get(mid).compareTo(c);
		if (compVal == 0) 
			return mid;
		else if (compVal < 0)
			lo = mid + 1;
		else
			hi = mid - 1;
	}
	return -1;

12/11/14:
Aim: How can we analyze algorithm efficiency?

Computer science vs. computer programming:
Computer scientists can be guys who don’t necessarily know how computers work, and analyze/think of algorithms in “pseudo”-code, without writing the code itself

Efficiency:
Algorithm efficiency can refer to space efficiency or time efficiency. Often the two are inversely correlated (though not always).
When distinguishing efficiency, it’s important to be aware of the difference between the efficiency of an algorithm vs the power of the computer on which it is being run.

Big-O Notation:
Used to formalize the analysis of algorithms.
Provides an estimated upper bound for the amount of “work” done. It is not an exact measure.
Refers to the efficiency of an algorithm as the amount of data (n) increases.
Think of as a graph with time as the dependent variable on the y-axis, and data (n) as the independent variable on the y-axis

Example:

 for (int i=0;  i < a.length; i++)
	a[i] = a[i] * 10;

Big-O value of this loop?
The loop increases at the same rate as n:
O(n)

 for (int i=0; i < a.length; i++)
	for (int j=0; j < a.length; j++)
		a[j] = a[j] + i;

Big-O value of this loop?
Every single increase in n results in n more passes:
O(n^2)

for (int i=0;  i < a.length; i++)
	a[i] = i;
for (int j=0;  j < a.length; j++)
	a[j] = a[j] +  10;

Big-O value of this loop?
O(n+n) —> O(n) because it’s still only linear

12/12/14
Aim: How can we find Big-O values?
Do Now: What are the Big-O values for the following code segments?
1)
for (int i=0; i < a.length; i ++)
	a[i] = i;
for (int j=0; j < a.length; j ++)
	a[j] = a[j] + 10;

Loop 1: O(n)
Loop 2: O(n)
1+2:    O(2n)
Answer: O(n)//we dont care about constants

2)
for (int i=0; i<10; i++)
	a[i] = i; 
for (int j=0; i < a.length; j ++)
	a[j] = a[j] + 5;
Loop 1: O(1)
Loop 2: O(n)
1+2:    O(1 + n)
Answer: O(n)//1 is negligible as n increases, so we ignore it

3)
for (int i=a.length; i >= 1; i /= 2)
	a[i] = a[i] * i;
Loop 1: O(log2n)
Answer: O(log n)

Log is much more efficient
Tips for evaluating Big-O values
Ignore any operation/loop/recursion that is independent of the size of the data.
These are called constant time operations.
When evaluating nested statements, find the Big-O value of each individual statement and then multiply them.
When evaluating consecutive (non-nested) statements, find the Big-I value of each, then select the Big-O value that is the largest.
example:

	for (int i=0; i< a.length; i++)
		for (int j=0; j < a.length; j ++)
			a[j] = a[j] + i;
	for (int i=0; i < a.length; i ++)
		a[i] = i;

Loop 1:   O(n)
Loop 2:   O(n)
Loop 3:   O(n)
(1)(2)+3: O(n^2 +n)
Answer:   O(n^2)//n is negligible as n^2 increases, so we ignore it

12/15/14 
Aim: Common Big-O Values (Continued)
Do Now: What are the Big-O values for the following?

1)
for (int i = 0; i < a.length; i++)
	a[i] = i;
for (int j = 1; j < a.length; j *= 2)
	a[j] = a[j] * 10;
Time Complexity: O(n) + O(log n) = O(n + log n) = O(n)

2)
public int foo(int k) {
	if (k <= 1) return 1;
	return foo(k - 1) + foo(k - 2);
}
Time Complexity: O(2n)

 
			   Fibonacci Recursive Tree Diagram
                                        foo(k)
                foo(k-1)                                      foo(k-2)
     foo(k-2)              foo(k-3)                foo(k-3)              foo(k-4)
foo(k-3)  foo(k-4)    foo(k-4)  foo(k-5)      foo(k-4)  foo(k-5)    foo(k-5)  foo(k-6)
  ...       ...         ...       ...           ...       ...         ...        ...

This algorithm for finding the Fibonacci numbers is, of course, highly inefficient.
Every call of foo(int n) leads to two more calls of the same method,
with every recursion tree leading down to a call of foo(1) or foo(0).
A much better algorithm would store values that it had already calculated,
starting with foo(0), foo(1), and continuing all the way up to foo(n).

3)
ArrayList goo;
for (int i = 0; i < 50; i++)
	goo.add(0, Math.random());
Time Complexity: O(1) * O(n) = O(n)
For every iteration of the loop, every value in the ArrayList is shifted by one unit.
Since ArrayList.add(int index, E element) is O(n), the loop itself is O(n).

Table of Common Big-O Values (also known as orders)
Order		Name			n = 10	n = 100				n = 1,000
O(1)		constant		1	1				1
O(log n)	logarithmic		3.3	6.6				9.9
O(n)		linear			10	100				1,000
O(n log n)	log-linear/linearithmic	33	664				9,970
O(n2)		quadratic		100	10,000				1,000,000
O(2n)		exponential		1,024	1.7x10^30			1.07x10^301

P = NP?
A very theoretical question with very practical applications!
Polynomial Time = Non-Polynomial Time?
If we can verify it in non-polynomial time, can we solve it in polynomial time?
Is the time it takes to run a program the same in non-polynomial time?

12/16/14
Aim: How can we sort data?
Discussion:

The fibonacci code we looked at and the Towers of Hanoi both use exponential algorithms.
-For Towers of Hanoi, there is no other algorithm to solve it other than exponential.

Quadratic(Polynomial) and above are known as polynomial-time algorithms.
-Any algorithm that can be do in polynomial-time is considered "easy" to do by computers.
-Anything that goes above that is considered "hard" (will take a long time).

P vs NP
-NP refers to any problem that can be verified in polynomial-time, but not necessarily solved in polynomial time.
-P refers to any problem that can be solved in polynomial time.
-A problem for computer scientists is to determine if a problem is P, given that it is NP.
-There are problems in NP that still cannot be solved in P.
-Website verification is in NP.
-Computer security uses NP, but if it is solvable in P, may cause SEVERE PROBLEMS.

Sorting
-We will learn 5 ways to solve things.
-For practice, the class was split into 3 groups of 10 to watch three different videos on sorting. Each group will demonstrate tomorrow the sorting method that has been used to show understanding of the method.


